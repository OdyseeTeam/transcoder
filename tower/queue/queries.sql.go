// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package queue

import (
	"context"
	"database/sql"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
  status, ulid, worker, url, sd_hash
) VALUES (
  'new', $1, $2, $3, $4
)
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

type CreateTaskParams struct {
	ULID   string
	Worker string
	URL    string
	SDHash string
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ULID,
		arg.Worker,
		arg.URL,
		arg.SDHash,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const getActiveTasks = `-- name: GetActiveTasks :many
SELECT id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result FROM tasks
WHERE status IN ('new', 'processing', 'retrying')
`

func (q *Queries) GetActiveTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ULID,
			&i.Status,
			&i.Retries,
			&i.Stage,
			&i.StageProgress,
			&i.Error,
			&i.Fatal,
			&i.Worker,
			&i.URL,
			&i.SDHash,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTasksForWorker = `-- name: GetActiveTasksForWorker :many
SELECT id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result FROM tasks
WHERE status IN ('new', 'processing', 'retrying') AND worker = $1
`

func (q *Queries) GetActiveTasksForWorker(ctx context.Context, worker string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTasksForWorker, worker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ULID,
			&i.Status,
			&i.Retries,
			&i.Stage,
			&i.StageProgress,
			&i.Error,
			&i.Fatal,
			&i.Worker,
			&i.URL,
			&i.SDHash,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRetriableTasks = `-- name: GetRetriableTasks :many
SELECT id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result FROM tasks
WHERE status = 'errored' AND (fatal IS FALSE OR retries < 10)
`

func (q *Queries) GetRetriableTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getRetriableTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ULID,
			&i.Status,
			&i.Retries,
			&i.Stage,
			&i.StageProgress,
			&i.Error,
			&i.Fatal,
			&i.Worker,
			&i.URL,
			&i.SDHash,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunnableTaskByPayload = `-- name: GetRunnableTaskByPayload :one
SELECT id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result FROM tasks
WHERE status != 'done' AND NOT (status = 'errored' AND fatal = 'true')
AND url = $1 AND sd_hash = $2 LIMIT 1
`

type GetRunnableTaskByPayloadParams struct {
	URL    string
	SDHash string
}

func (q *Queries) GetRunnableTaskByPayload(ctx context.Context, arg GetRunnableTaskByPayloadParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, getRunnableTaskByPayload, arg.URL, arg.SDHash)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const getTask = `-- name: GetTask :one
SELECT id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result FROM tasks
WHERE ulid = $1 LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, ulid string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, ulid)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const markDone = `-- name: MarkDone :one
UPDATE tasks
SET status = 'done', stage = 'done', result = $2, updated_at = NOW() WHERE ulid = $1
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

type MarkDoneParams struct {
	ULID   string
	Result sql.NullString
}

func (q *Queries) MarkDone(ctx context.Context, arg MarkDoneParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, markDone, arg.ULID, arg.Result)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const markRetrying = `-- name: MarkRetrying :one
UPDATE tasks
SET status = 'retrying', retries = retries + 1, updated_at = NOW() WHERE ulid = $1
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

func (q *Queries) MarkRetrying(ctx context.Context, ulid string) (Task, error) {
	row := q.db.QueryRowContext(ctx, markRetrying, ulid)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const setError = `-- name: SetError :one
UPDATE tasks
SET status = 'errored', error = $2, fatal = $3, updated_at = NOW() WHERE ulid = $1
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

type SetErrorParams struct {
	ULID  string
	Error sql.NullString
	Fatal sql.NullBool
}

func (q *Queries) SetError(ctx context.Context, arg SetErrorParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, setError, arg.ULID, arg.Error, arg.Fatal)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const setStageProgress = `-- name: SetStageProgress :one
UPDATE tasks
SET stage = $2, stage_progress = $3, status = 'processing', updated_at = NOW() WHERE ulid = $1
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

type SetStageProgressParams struct {
	ULID          string
	Stage         sql.NullString
	StageProgress sql.NullInt32
}

func (q *Queries) SetStageProgress(ctx context.Context, arg SetStageProgressParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, setStageProgress, arg.ULID, arg.Stage, arg.StageProgress)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}

const setStatus = `-- name: SetStatus :one
UPDATE tasks
SET status = $2 WHERE ulid = $1
RETURNING id, created_at, updated_at, ulid, status, retries, stage, stage_progress, error, fatal, worker, url, sd_hash, result
`

type SetStatusParams struct {
	ULID   string
	Status Status
}

func (q *Queries) SetStatus(ctx context.Context, arg SetStatusParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, setStatus, arg.ULID, arg.Status)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ULID,
		&i.Status,
		&i.Retries,
		&i.Stage,
		&i.StageProgress,
		&i.Error,
		&i.Fatal,
		&i.Worker,
		&i.URL,
		&i.SDHash,
		&i.Result,
	)
	return i, err
}
